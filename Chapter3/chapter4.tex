	\headerandfooterconfig
\graphicspath{Chapter4/Chapter4Figs/}
\chapter{Thiết kế và thực hiện phần mềm}
\section{Thiết kế kiến trúc phần mềm}
\subsection{Các thành phần}
Kiến trúc phần mềm của hệ thống nhận diện ổ gà gồm nhiều phần:
\begin{itemize}
\item Chương trình chạy trong Arduino giúp vận hành thiết bị cảm biến ổ gà, gửi dữ liệu lên MQTT Broker qua giao thức MQTT.
\item Cấu hình hệ thống MQTT Broker.
\item Cấu hình Hệ Quản trị cơ sở dữ liệu MySQL.
\item Kết nối Broker với Database.
\item Thiết kế giao diện Web.
\end{itemize}
\subsection{Yêu cầu thiết kế}
\begin{itemize}
\item Đáp ứng thực hiện đầy đủ các thành phần trong kiến trúc phần mềm hệ thống.
\item Đảm bảo hệ thống vận hành chính xác, hiệu quả, độ trễ thấp, bền vững.
\item Giao diện thân thiện, dễ truy cập, ít tốn tài nguyên.
\end{itemize}

\section{Thực hiện phần mềm}
\subsection{Chương trình trong Arduino}
\subsubsection{Lưu đồ giải thuật}
\Figure{htp}{7}{Chapter4/Chapter4Figs/fig4_1}{Lưu đồ giải thuật chương trình Arduino}
\label{ref{fig4_1}}

\subsubsection{Chương trình}
\begin{lstlisting}[style=myArduino]
#include "SoftwareSerial.h"
#include "TinyGPS.h"
#include "stdio.h"
#include "string.h"
#include <conio.h>

//GPS
TinyGPS gps;
SoftwareSerial ss(8, 7);  //8:RX,7:TX
SoftwareSerial Serial2(6, 5); //6:RX
//Cam bien sieu am
const int trig = 11;     // chan trig cua HC-SR05
const int echo = 10;     // chan echo cua HC-SR05
int timer;
//Module Sim A7
char aux_str[100];
const char * __APN      = "internet";
const char * __usrnm    = "";
const char * __password = "";

unsigned int Counter = 0;
unsigned long datalength, checksum, rLength;
unsigned short topiclength;
unsigned short topiclength2;
unsigned char topic[30];
char data[250];
char str[250];
unsigned char encodedByte;
int X;

unsigned short MQTTProtocolNameLength;
unsigned short MQTTClientIDLength;
unsigned short MQTTUsernameLength;
unsigned short MQTTPasswordLength;
unsigned short MQTTTopicLength;

const char * MQTTHost = "m23.cloudmqtt.com";    //IP cua MQTT 
const char * MQTTPort = "12700";                //Port
const char * MQTTClientID = "ABCDEF";           //Client ID
const char * MQTTTopic = "data";                //Topic
const char * MQTTProtocolName = "MQIsdp";       //Protocol Name
const char MQTTLVL = 0x03;                      //Level
const char MQTTFlags = 0xC2;                    //Flags
const unsigned int MQTTKeepAlive = 60;          //Time Connect
const char * MQTTUsername = "fwenajrr";        
const char * MQTTPassword = "8Fzfn9sPb9CI";
const char MQTTQOS = 0x00;
const char MQTTPacketID = 0x0001;

//Khai bao bien toan cuc
int start = 0;
//GPS
float flat = 2.356825, flon=100.533558;    //Dia chi kinh do va vi do
unsigned long age, date, time, chars = 0;
int year;
byte month, day, hour, minute, second, hundredths;  //Thoi gian
unsigned short sentences = 0, failed = 0;
//Cam bien sieu am
unsigned long duration; // Bien do thoi gian
int New_distance,distance,const_distance;          // Bien luu khoang cach
int delta;
//int pothole;


void setup()
{
  Serial.begin(9600);      //Giao tiep voi module sim
  ss.begin(9600);          //Giao tiep voi NEO6 - GPS
  pinMode(trig,OUTPUT);    // chan trig se phat tin hieu
  pinMode(echo,INPUT);     // chan echo se nhan tin hieu
  start = 1;
  
  
  power_on();  //Ham gui lien tuc lenh AT de kiem tra SIM800 co hoat dong khong, neu co thi bo qua
  Serial.print("ATE0\r\n");
  delay(5000);
  Serial.print("AT+CIPMUX=0\r\n");
  delay(5000);
  Serial.print("AT+CSTT=\"internet\",\"\",\"\"\r\n");
  delay(5000);
  Serial.print("AT+CIICR\r\n");
  delay(5000);
  Serial.print("AT+CIFSR\r\n");  //Cac lenh can thiet de thiet lap mang cho Sim
  delay(5000);

  
  New_distance = Detect();  //Lay khoang cac dau mat duong sau qua trinh cai dat
  location_get();           //Lay toa do GPS sau qua trinh cai dat
  MQTTConnect();            //Ket noi toi server MQTT
  delay(2000);
}

void loop()
{
   if(start)  //Ban dau gan voi gia tri hang so lam khoang cach tu cam bien toi mat duong
   {
   const_distance = New_distance;
   }
   start = 0;
   distance = Detect();  //Doc lien tuc khoang cach de check
   //delta = distance - const_distance;
   if((distance-const_distance)>=5)  //Neu khoang cach > 5cm ==> gui toa do len MQTT
   {
   location_get();
   MQTTConnect();  //Ket noi toi MQTT
   MQTTpublish();  //Gui toa do len MQTT
   //start = 1;
   }
   //delay(1000);*/
}


void power_on()
{
  uint8_t answer=0;
  int ctT=0;
 
  answer = sendATcommand("AT\r\n","OK",2000);
  delay(3000);
  while(answer==0)
  {
    answer = sendATcommand("AT\r\n","OK",2000);
    delay(3000);
    ctT++;
    if(ctT==10)  //Neu qua 10 lan thi khoi dong lai PWM Key
    {
      power_on();
    }
  }
 //sendATcommand("ATE0\r\n","OK",2000);
}

int8_t sendATcommand(char* ATcommand, char* expected_answer, unsigned int timeout)   
//Ham gui lenh AT va se tra ve gia tri la 1 neu khong co loi khi gui
{
  uint8_t x=0, answer=0;
  char response[50];
  unsigned long previous;
  char str;
  uint8_t index = 0;

  memset(response, '\0',50);
  delay(1000);
  //while( Serial.available() > 0) Serial.read();    // Clean the input buffer

  Serial.print(ATcommand);

  x = 0;
  previous = millis();    //Tra ve thoi gian tu luc chuong trinh hoat dong
  {
    if(Serial.available() > 0)
    {    
      // if there is data in the UART input buffer, read it and checks for the asnwer
      response[x] = Serial.read();     //Read Response from Serial1 port
      //Serial.print(response[x]);        //Print response on Serial 0 port
      x++;

      // check if the desired answer  is in the response of the module
        if (strstr(response, expected_answer) != NULL)    
      {
        answer = 1;
      }
    }
  }// do
  // Waits for the asnwer with time out
  while((answer == 0) && ((millis() - previous) < timeout));    //Check till answer = 0 and timout period(ms)
  return answer;
}

void MQTTConnect() {
  Serial.print("AT+CIPSTART=\"TCP\",\"m23.cloudmqtt.com\",12700\r\n");
  delay(7000);
  
  Serial.print("AT+CIPSEND\r\n");
  delay(1000);
    Serial.write(0x10);
    MQTTProtocolNameLength = strlen(MQTTProtocolName);
    MQTTClientIDLength = strlen(MQTTClientID);
    MQTTUsernameLength = strlen(MQTTUsername);
    MQTTPasswordLength = strlen(MQTTPassword);
    datalength = MQTTProtocolNameLength + 2 + 4 + MQTTClientIDLength + 2 + MQTTUsernameLength + 2 + MQTTPasswordLength + 2;
    X = datalength;
    do
    {
      encodedByte = X % 128;
      X = X / 128;
      // if there are more data to encode, set the top bit of this byte
      if ( X > 0 ) {
        encodedByte |= 128;
      }

      Serial.write(encodedByte);
    }
    while ( X > 0 );
    Serial.write(MQTTProtocolNameLength >> 8);
    Serial.write(MQTTProtocolNameLength & 0xFF);
    Serial.write(MQTTProtocolName);

    Serial.write(MQTTLVL); // LVL
    Serial.write(MQTTFlags); // Flags
    Serial.write(MQTTKeepAlive >> 8);
    Serial.write(MQTTKeepAlive & 0xFF);


    Serial.write(MQTTClientIDLength >> 8);
    Serial.write(MQTTClientIDLength & 0xFF);
    Serial.print(MQTTClientID);


    Serial.write(MQTTUsernameLength >> 8);
    Serial.write(MQTTUsernameLength & 0xFF);
    Serial.print(MQTTUsername);


    Serial.write(MQTTPasswordLength >> 8);
    Serial.write(MQTTPasswordLength & 0xFF);
    Serial.print(MQTTPassword);

    Serial.write(0x1A);
    
    
}


void MQTTpublish() {
  char kinhdodata[10],vidodata[10];
  char kinhdo[10],vido[10];


  
  Serial.print("AT+CIPSEND\r\n");
  delay(1000);

    memset(str, 0, sizeof(str));
    memset(data, 0, sizeof(data));
    
    
    location_get();
    dtostrf(flat, 3, 6, kinhdodata);
    dtostrf(flon, 3, 6, vidodata);
    sprintf((char*)data,"%d/%d/%d,%d:%d:%d,%s,%s",year,(int*)month,(int*)date,(int*)hour+7,(int*)minute,(int*)second,kinhdodata,vidodata);
   
    topiclength = sprintf((char*)topic, MQTTTopic);

    

    

    datalength = sprintf((char*)str, "%s%s", topic,data);

    delay(1000);
    Serial.write(0x30);
    X = datalength + 2;
    do
    {
      encodedByte = X % 128;
      X = X / 128;
      // if there are more data to encode, set the top bit of this byte
      if ( X > 0 ) {
        encodedByte |= 128;
      }
      Serial.write(encodedByte);
    }
    while ( X > 0 );

    Serial.write(topiclength >> 8);
    Serial.write(topiclength & 0xFF);
    Serial.print(str);
    Serial.write(0x1A);
    
    delay(1000);
    Serial.print("AT+CIPSHUT\r\n");
    delay(1000);
}

static void print_int(unsigned long val, unsigned long invalid, int len)
{
  char sz[32];
  if (val == invalid)
    strcpy(sz, "*******");
  else
    sprintf(sz, "%ld", val);
  sz[len] = 0;
  for (int i=strlen(sz); i<len; ++i)
    sz[i] = ' ';
  if (len > 0) 
    sz[len-1] = ' ';
  Serial.print(sz);
  smartdelay(0);
}
// Ham in ngay thang 
// Ham in chuoi
static void print_str(const char *str, int len)
{
  int slen = strlen(str);
  for (int i=0; i<len; ++i)
    Serial.print(i<slen ? str[i] : ' ');
  smartdelay(0);
}





int Detect()
{
  /* Phat xung tu chan trig */
  digitalWrite(trig,0);   // tat chan trig
  delayMicroseconds(2);
  digitalWrite(trig,1);   // phat xung tu chan trig
  delayMicroseconds(5);   // xung co do dai 5 microSeconds
  digitalWrite(trig,0);   // tat chan trig

  /* Tinh toan thoi gian */
  //Do do rong xung HIGH o chan echo
   duration = pulseIn(echo,HIGH);  
  // Tinh khoang cach den vat the.
  distance = int(duration/2/29.412);
  //pothole = digitalRead(echo);
  /*while(pothole == 0)
   {
   while(pothole == 1)
   {
   GPS_Send();
   break;
   }
   break;
   }*/
  delay(200);
  return distance;
}

static void location_get(void)
{
  //   float flat, flon;
  // unsigned long age, date, time, chars = 0;
  // unsigned short sentences = 0, failed = 0;
  static const double LONDON_LAT = 10.760497, LONDON_LON = 106.661788;	//Thong tin toa do London
  //Lay thong tin gps va in ra man hinh
  //print_int(gps.satellites(), TinyGPS::GPS_INVALID_SATELLITES, 5);
  //print_int(gps.hdop(), TinyGPS::GPS_INVALID_HDOP, 5);
  gps.f_get_position(&flat, &flon, &age);
  print_float(flat, TinyGPS::GPS_INVALID_F_ANGLE, 10, 6);
  print_float(flon, TinyGPS::GPS_INVALID_F_ANGLE, 11, 6);
  // print_int(age, TinyGPS::GPS_INVALID_AGE, 5);  //
  print_date(gps);
  //print_float(gps.f_altitude(), TinyGPS::GPS_INVALID_F_ALTITUDE, 7, 2);  //
  // print_float(gps.f_course(), TinyGPS::GPS_INVALID_F_ANGLE, 7, 2);  //
  //print_float(gps.f_speed_kmph(), TinyGPS::GPS_INVALID_F_SPEED, 6, 2);  //
  //print_str(gps.f_course() == TinyGPS::GPS_INVALID_F_ANGLE ? "*** " : TinyGPS::cardinal(gps.f_course()), 6);  //
  //print_int(flat == TinyGPS::GPS_INVALID_F_ANGLE ? 0xFFFFFFFF : (unsigned long)TinyGPS::distance_between(flat, flon, LONDON_LAT, LONDON_LON) / 1000, 0xFFFFFFFF, 9);  //        
  //print_float(flat == TinyGPS::GPS_INVALID_F_ANGLE ? TinyGPS::GPS_INVALID_F_ANGLE : TinyGPS::course_to(flat, flon, LONDON_LAT, LONDON_LON), TinyGPS::GPS_INVALID_F_ANGLE, 7, 2);  //
  //print_str(flat == TinyGPS::GPS_INVALID_F_ANGLE ? "*** " : TinyGPS::cardinal(TinyGPS::course_to(flat, flon, LONDON_LAT, LONDON_LON)), 6);  // 

  //  gps.stats(&chars, &sentences, &failed);  //
  //print_int(chars, 0xFFFFFFFF, 6);  //
  // print_int(sentences, 0xFFFFFFFF, 10);  //
  //print_int(failed, 0xFFFFFFFF, 9);  //
  Serial.println();

  smartdelay(1000);

}

static void smartdelay(unsigned long ms)
{
  unsigned long start = millis();
  do 
  {
    while (ss.available())
      gps.encode(ss.read());
  } 
  while (millis() - start < ms);
}

static void print_float(float val, float invalid, int len, int prec)
{
  if (val == invalid)
  {
    while (len-- > 1)
      Serial.print('*');
    Serial.print(' ');
  }
  else
  {
    Serial.print(val, prec);
    int vi = abs((int)val);
    int flen = prec + (val < 0.0 ? 2 : 1); // . and -
    flen += vi >= 1000 ? 4 : vi >= 100 ? 3 : vi >= 10 ? 2 : 1;
    for (int i=flen; i<len; ++i)
      Serial.print(' ');
  }
  smartdelay(0);
}

static void print_date(TinyGPS &gps)
{
  unsigned long age;
  gps.crack_datetime(&year, &month, &day, &hour, &minute, &second, &hundredths, &age);
  if (age == TinyGPS::GPS_INVALID_AGE)
    Serial.print("********** ******** ");
  else
  {
    char sz[32];
    sprintf(sz, "%02d/%02d/%02d %02d:%02d:%02d ",
    month, day, year, hour+7, minute, second);
    Serial.print(sz);
  }
  smartdelay(0);
}

\end{lstlisting}

\subsection{Cấu hình hệ thống MQTT Broker}
Hiện nay, có nhiều Broker Opensource như: Mosquitto, EMQ (EMQTTD), Vernemq, HiveMQ,...Trong đồ án này, nhóm chúng em sử dụng CloudMQTT \\
CloudMQTT là giải pháp hoàn hảo cho thông điệp "Internet of Things" giữa các cảm biến điện năng thấp hoặc các thiết bị di động như điện thoại, máy tính nhúng hoặc vi điều khiển như Arduino. CloudMQTT sử dụng ứng dụng WebMocketT Websocket để xem các tin nhắn được đẩy từ thiết bị đến trình duyệt hoặc xuất bản tin nhắn từ trình duyệt tới thiết bị. Điều này lý tưởng để thử nghiệm và gỡ lỗi vì người dùng có thể hiển thị thông tin trực tiếp từ thiết bị hoặc cảm biến trong thời gian thực.
Các bước cấu hình được trình bày gồm:
\begin{enumerate}
\item Truy cập vào $https://www.cloudmqtt.com/$ và tạo một tài khoản. Sau khi nhập email, sẽ có một đường link để kích hoạt thông tin và cấu hình cho tài khoản.
\item Tạo MQTT Broker bằng cách ấn vào nút Create, nhập các thông tin để cấu hình Broker.
\item Tạo một User dành cho máy tính để truy cập lấy dữ liệu sau này.
\item Tạo một Topic để nhận dữ liệu gửi về và phân phát dữ liệu.
\end{enumerate}

\Figure{!htp}{12}{Chapter4/Chapter4Figs/fig4_2}{Nhập địa chỉ email để tạo tài khoản trên CloudMQTT}
\label{ref{fig4_2}}

\Figure{!htp}{12}{Chapter4/Chapter4Figs/fig4_3}{Cấu hình cho tài khoản CloudMQTT}
\label{ref{fig4_3}}

\Figure{!htp}{12}{Chapter4/Chapter4Figs/fig4_4}{Cấu hình Broker trên CloudMQTT}
\label{ref{fig4_4}}

\Figure{!htp}{12}{Chapter4/Chapter4Figs/fig4_5}{Thông tin của Broker sau khi tạo}
\label{ref{fig4_5}}

\Figure{!htp}{12}{Chapter4/Chapter4Figs/fig4_6}{Tạo User trên CloudMQTT}
\label{ref{fig4_6}}

\Figure{!htp}{12}{Chapter4/Chapter4Figs/fig4_7}{Tạo Topic trên CloudMQTT}
\label{ref{fig4_7}}
\newpage

\subsection{Cấu hình Hệ Quản trị cơ sở dữ liệu MySQL}

\subsubsection{Cài đặt XAMPP}
Xampp là chương trình tạo máy chủ Web (Web Server) được tích hợp sẵn Apache, PHP, MySQL, FTP Server, Mail Server và các công cụ như phpMyAdmin. Không như Appserv, Xampp có chương trình quản lý khá tiện lợi, cho phép chủ động bật tắt hoặc khởi động lại các dịch vụ máy chủ bất kỳ lúc nào.
\Figure{!htp}{12}{Chapter4/Chapter4Figs/fig4_8}{Bảng điều khiển của XAMPP}
\label{ref{fig4_8}}
Hai ứng dụng Apache và MySQL có nút Start, đó là dấu hiệu bảo 2 ứng dụng này chưa được khởi động, hãy ấn vào nút Start của từng ứng dụng để khởi động Webserver Apache và MySQL Server lên thì mới chạy được localhost.

\subsubsection{Cài đặt MySQL Workbench}
MySQL Workbench là trình trực quan để giao tiếp với MySQL, nó thực hiện hiển thị đồ họa cho người dùng như các bảng, các database, mô hình… Nếu không có nó thì ta sẽ phải giao tiếp với MySQL bằng giao diện dòng lệnh khá phức tạp và mất thời gian.\\
(Một số phần mềm giống như MySQL Workbench như SQLoy, SQLWorkbench J…)\\
\begin{enumerate}
\item Truy cập đường link để tải bản MySQL Workbench: $https://dev.mysql.com/downloads$\\
\Figure{!htp}{12}{Chapter4/Chapter4Figs/fig4_9}{Truy cập đường link để tải bản MySQL Workbench}
\label{ref{fig4_9}}
\item Sau khi cài đặt xong, ta có giao diện như sau.
\Figure{!htp}{12}{Chapter4/Chapter4Figs/fig4_10}{Giao diện MySQL Workbench}
\label{ref{fig4_10}}
\item Tiến hành nhập user và password đã khởi tạo.
\item Tạo một database, ở đây database được tạo với tên là \textbf{$db_pothole$}.
\item Tạo bảng \textbf{$data_1$} lưu dữ liệu về ổ gà.
\end{enumerate}
Cơ sở dữ liệu có thể quan sát trực quan bằng phpMyAdmin tích hợp trên Xampp.
\Figure{!htp}{14}{Chapter4/Chapter4Figs/fig4_12}{Giao diện cơ sở dữ liệu trên phpMyAdmin}
\label{ref{fig4_12}}
\Figure{!htp}{14}{Chapter4/Chapter4Figs/fig4_13}{Cấu trúc các cột trong bảng dữ liệu}
\label{ref{fig4_13}}
\subsection{Kết nối Broker với Database}
Quá trình kết nối đến CloudMQTT giống như việc đăng kí một kênh thông tin để khi có dữ liệu, broker sẽ phân phát dữ liệu xuống cho user.\\
Cấu hình user cho máy tính (localhost) đã được thực hiện trong bước cấu hình \textbf{Broker}.\\
Chương trình thực hiện việc kết nối được viết bằng ngôn ngữ NodeJS trên phần mềm WebStorm của JetBrains.
Các bước như sau:
\begin{enumerate}
\item Tạo một project trong WebStorm.
\item Cài đặt thư viện npm mqtt. Chạy code như sau $npm install mqtt --save$
\item Tạo một file JaveScript trong project. 
\item Run file JavaScript.
\end{enumerate}
Code như sau:
\begin{lstlisting}[style=myArduino]
var mqtt = require('mqtt')
var client  = mqtt.connect('mqtt://pc:06071997@m23.cloudmqtt.com:12700')
%pc=username 06071997=user_password m23.cloudmqtt.com:12700=host.port
var mysql = require('mysql');

%connect to database
var con = mysql.createConnection({
    host: "127.0.0.1", %database_host
    user: "root", %database_user
    password: "06071997", %database_password
    database: "db_pothole" %database_name
});

%connect to mqtt_broker
        client.on('connect', function () {
        client.subscribe('data')
      

    })
    con.connect(function (err) {
        if (err) throw err;
        console.log("Connected!");
    });
%get message and transform it to separated part
    client.on('message', function (topic, message) {
        var str = message.toString();
        var str = str.split(",");
        var date= str[0];
        var time= str[1];
        var lat = str[2];
        var lon = str[3];
%insert to database_table
        var sql = "INSERT INTO data_1 (Date, Time, Latitude, Longitude) VALUES ("+date+","+time+","+ lat + ","+lon+")";
            con.query(sql, function (err, result) {
            if (err) throw err;
            console.log("1 record inserted");

        });
        console.log(message.toString())
    })
\end{lstlisting}

\subsection{Thiết kế giao diện Web}
\subsubsection{Yêu cầu}
\begin{itemize}
\item Giao diện web phải trực quan, dễ sử dụng.
\item Dễ truy cập.
\end{itemize}
Phần web (Frontend) được nhóm thực hiện phía localhost để dễ thực thi và kiểm tra. Sau khi thiết kế thành công, web được đẩy lên host và hoạt động dưới môi trường internet để người dừng có thể tiếp cận bằng bất kì phương tiện có kết nối mạng.
\subsubsection{Giao diện web}
